"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.calculateUpdateRequest = exports.getExtensionArn = exports.getLayerArn = exports.getFunctionConfiguration = exports.updateLambdaConfigs = exports.getLambdaConfigsFromRegEx = exports.getLambdaConfigs = void 0;
const constants_1 = require("./constants");
const loggroup_1 = require("./loggroup");
const tags_1 = require("./tags");
const MAX_LAMBDA_STATE_CHECKS = 3;
/**
 * Waits for n ms
 * @param ms
 * @returns
 */
const wait = (ms) => new Promise((res) => setTimeout(res, ms));
const isLambdaActive = (lambda, config, functionArn, attempts = 0) => __awaiter(void 0, void 0, void 0, function* () {
    // TODO remove 1 Oct 2021 https://aws.amazon.com/blogs/compute/tracking-the-state-of-lambda-functions/
    if (!config.State || !config.LastUpdateStatus) {
        return true;
    }
    if (config.LastUpdateStatus === 'Successful' && config.State === 'Active') {
        return true;
    }
    if (config.State === 'Pending' && attempts <= MAX_LAMBDA_STATE_CHECKS) {
        yield wait(Math.pow(2, attempts) * 1000);
        const refetchedConfig = yield getLambdaConfig(lambda, functionArn);
        return isLambdaActive(lambda, refetchedConfig, functionArn, (attempts += 1));
    }
    throw Error(`Can't instrument ${functionArn}, as current State is ${config.State} (must be "Active") and Last Update Status is ${config.LastUpdateStatus} (must be "Successful")`);
});
const getLambdaConfigs = (lambda, cloudWatch, region, functionARNs, settings) => __awaiter(void 0, void 0, void 0, function* () {
    const resultPromises = functionARNs.map((fn) => getLambdaConfig(lambda, fn));
    const results = yield Promise.all(resultPromises);
    const functionsToUpdate = [];
    for (const config of results) {
        const functionConfiguration = yield exports.getFunctionConfiguration(lambda, cloudWatch, config, region, settings);
        functionsToUpdate.push(functionConfiguration);
    }
    return functionsToUpdate;
});
exports.getLambdaConfigs = getLambdaConfigs;
const getLambdaConfigsFromRegEx = (lambda, cloudWatch, region, pattern, settings) => __awaiter(void 0, void 0, void 0, function* () {
    var _a;
    const regEx = new RegExp(pattern);
    const matchedFunctions = [];
    let retryCount = 0;
    let listFunctionsResponse;
    let nextMarker;
    while (true) {
        try {
            listFunctionsResponse = yield lambda.listFunctions({ Marker: nextMarker }).promise();
            (_a = listFunctionsResponse.Functions) === null || _a === void 0 ? void 0 : _a.map((fn) => { var _a; return ((_a = fn.FunctionName) === null || _a === void 0 ? void 0 : _a.match(regEx)) && matchedFunctions.push(fn); });
            nextMarker = listFunctionsResponse.NextMarker;
            if (!nextMarker) {
                break;
            }
            retryCount = 0;
        }
        catch (e) {
            retryCount++;
            if (retryCount > constants_1.LIST_FUNCTIONS_MAX_RETRY_COUNT) {
                throw Error('Max retry count exceeded.');
            }
        }
    }
    const functionsToUpdate = [];
    for (const config of matchedFunctions) {
        const functionConfiguration = yield exports.getFunctionConfiguration(lambda, cloudWatch, config, region, settings);
        functionsToUpdate.push(functionConfiguration);
    }
    return functionsToUpdate;
});
exports.getLambdaConfigsFromRegEx = getLambdaConfigsFromRegEx;
const updateLambdaConfigs = (lambda, cloudWatch, configurations) => __awaiter(void 0, void 0, void 0, function* () {
    const results = configurations.map((c) => __awaiter(void 0, void 0, void 0, function* () {
        if (c.updateRequest !== undefined) {
            yield lambda.updateFunctionConfiguration(c.updateRequest).promise();
        }
        if (c.logGroupConfiguration !== undefined) {
            yield loggroup_1.applyLogGroupConfig(cloudWatch, c.logGroupConfiguration);
        }
        if (c.tagConfiguration !== undefined) {
            yield tags_1.applyTagConfig(lambda, c.tagConfiguration);
        }
    }));
    yield Promise.all(results);
});
exports.updateLambdaConfigs = updateLambdaConfigs;
const getLambdaConfig = (lambda, functionARN) => __awaiter(void 0, void 0, void 0, function* () {
    const params = {
        FunctionName: functionARN,
    };
    const result = yield lambda.getFunction(params).promise();
    // AWS typescript API is slightly mistyped, adds undefineds where
    // there shouldn't be.
    const config = result.Configuration;
    return config;
});
const getFunctionConfiguration = (lambda, cloudWatch, config, region, settings) => __awaiter(void 0, void 0, void 0, function* () {
    const functionARN = config.FunctionArn;
    const runtime = config.Runtime;
    if (!isSupportedRuntime(runtime)) {
        throw Error(`Can't instrument ${functionARN}, runtime ${runtime} not supported`);
    }
    yield isLambdaActive(lambda, config, functionARN);
    const lambdaLibraryLayerArn = exports.getLayerArn(runtime, settings, region);
    const lambdaExtensionLayerArn = exports.getExtensionArn(settings, region);
    const updateRequest = exports.calculateUpdateRequest(config, settings, lambdaLibraryLayerArn, lambdaExtensionLayerArn, runtime);
    let logGroupConfiguration;
    if (settings.forwarderARN !== undefined) {
        const arn = `/aws/lambda/${config.FunctionName}`;
        logGroupConfiguration = yield loggroup_1.calculateLogGroupUpdateRequest(cloudWatch, arn, settings.forwarderARN);
    }
    const tagConfiguration = yield tags_1.calculateTagUpdateRequest(lambda, functionARN);
    return {
        functionARN,
        lambdaConfig: config,
        lambdaLibraryLayerArn,
        logGroupConfiguration,
        tagConfiguration,
        updateRequest,
    };
});
exports.getFunctionConfiguration = getFunctionConfiguration;
const getLayerArn = (runtime, settings, region) => {
    var _a;
    const layerName = constants_1.RUNTIME_LAYER_LOOKUP[runtime];
    const account = (_a = settings.layerAWSAccount) !== null && _a !== void 0 ? _a : constants_1.DEFAULT_LAYER_AWS_ACCOUNT;
    const isGovCloud = region.startsWith('us-gov');
    if (isGovCloud) {
        return `arn:aws-us-gov:lambda:${region}:${constants_1.GOVCLOUD_LAYER_AWS_ACCOUNT}:layer:${layerName}`;
    }
    return `arn:aws:lambda:${region}:${account}:layer:${layerName}`;
};
exports.getLayerArn = getLayerArn;
const getExtensionArn = (settings, region) => {
    var _a;
    const layerName = constants_1.DD_LAMBDA_EXTENSION_LAYER_NAME;
    const account = (_a = settings.layerAWSAccount) !== null && _a !== void 0 ? _a : constants_1.DEFAULT_LAYER_AWS_ACCOUNT;
    const isGovCloud = region.startsWith('us-gov');
    if (isGovCloud) {
        return `arn:aws-us-gov:lambda:${region}:${constants_1.GOVCLOUD_LAYER_AWS_ACCOUNT}:layer:${layerName}`;
    }
    return `arn:aws:lambda:${region}:${account}:layer:${layerName}`;
};
exports.getExtensionArn = getExtensionArn;
const calculateUpdateRequest = (config, settings, lambdaLibraryLayerArn, lambdaExtensionLayerArn, runtime) => {
    var _a, _b, _c, _d, _e;
    const oldEnvVars = Object.assign({}, (_a = config.Environment) === null || _a === void 0 ? void 0 : _a.Variables);
    const changedEnvVars = {};
    const functionARN = config.FunctionArn;
    const apiKey = process.env[constants_1.CI_API_KEY_ENV_VAR];
    const apiKmsKey = process.env[constants_1.CI_KMS_API_KEY_ENV_VAR];
    const site = process.env[constants_1.CI_SITE_ENV_VAR];
    if (functionARN === undefined) {
        return undefined;
    }
    const updateRequest = {
        FunctionName: functionARN,
    };
    let needsUpdate = false;
    // Update Handler
    const expectedHandler = constants_1.HANDLER_LOCATION[runtime];
    if (config.Handler !== expectedHandler) {
        needsUpdate = true;
        updateRequest.Handler = constants_1.HANDLER_LOCATION[runtime];
    }
    // Update Env Vars
    if (oldEnvVars[constants_1.LAMBDA_HANDLER_ENV_VAR] === undefined) {
        needsUpdate = true;
        changedEnvVars[constants_1.LAMBDA_HANDLER_ENV_VAR] = (_b = config.Handler) !== null && _b !== void 0 ? _b : '';
    }
    if (apiKey !== undefined && oldEnvVars[constants_1.API_KEY_ENV_VAR] !== apiKey) {
        needsUpdate = true;
        changedEnvVars[constants_1.API_KEY_ENV_VAR] = apiKey;
    }
    if (apiKmsKey !== undefined && oldEnvVars[constants_1.KMS_API_KEY_ENV_VAR] !== apiKmsKey) {
        needsUpdate = true;
        changedEnvVars[constants_1.KMS_API_KEY_ENV_VAR] = apiKmsKey;
    }
    if (site !== undefined && oldEnvVars[constants_1.SITE_ENV_VAR] !== site) {
        const siteList = ['datadoghq.com', 'datadoghq.eu', 'us3.datadoghq.com', 'ddog-gov.com'];
        if (siteList.includes(site.toLowerCase())) {
            needsUpdate = true;
            changedEnvVars[constants_1.SITE_ENV_VAR] = site;
        }
        else {
            throw new Error('Warning: Invalid site URL. Must be either datadoghq.com, datadoghq.eu, us3.datadoghq.com, or ddog-gov.com.');
        }
    }
    if (site === undefined && oldEnvVars[constants_1.SITE_ENV_VAR] === undefined) {
        needsUpdate = true;
        changedEnvVars[constants_1.SITE_ENV_VAR] = 'datadoghq.com';
    }
    const environmentVarsTupleArray = [
        ['environment', constants_1.ENVIRONMENT_ENV_VAR],
        ['extraTags', constants_1.EXTRA_TAGS_ENV_VAR],
        ['flushMetricsToLogs', constants_1.FLUSH_TO_LOG_ENV_VAR],
        ['mergeXrayTraces', constants_1.MERGE_XRAY_TRACES_ENV_VAR],
        ['service', constants_1.SERVICE_ENV_VAR],
        ['tracingEnabled', constants_1.TRACE_ENABLED_ENV_VAR],
        ['version', constants_1.VERSION_ENV_VAR],
    ];
    for (const [key, environmentVar] of environmentVarsTupleArray) {
        if (settings[key] !== undefined && oldEnvVars[environmentVar] !== ((_c = settings[key]) === null || _c === void 0 ? void 0 : _c.toString())) {
            needsUpdate = true;
            changedEnvVars[environmentVar] = settings[key].toString();
        }
    }
    const newEnvVars = Object.assign(Object.assign({}, oldEnvVars), changedEnvVars);
    if (newEnvVars[constants_1.LOG_LEVEL_ENV_VAR] !== settings.logLevel) {
        needsUpdate = true;
        if (settings.logLevel) {
            newEnvVars[constants_1.LOG_LEVEL_ENV_VAR] = settings.logLevel;
        }
        else {
            delete newEnvVars[constants_1.LOG_LEVEL_ENV_VAR];
        }
    }
    updateRequest.Environment = {
        Variables: newEnvVars,
    };
    // Update Layers
    let fullLambdaLibraryLayerARN;
    if (settings.layerVersion !== undefined) {
        fullLambdaLibraryLayerARN = `${lambdaLibraryLayerArn}:${settings.layerVersion}`;
    }
    let fullExtensionLayerARN;
    if (settings.extensionVersion !== undefined) {
        fullExtensionLayerARN = `${lambdaExtensionLayerArn}:${settings.extensionVersion}`;
    }
    let layerARNs = ((_d = config.Layers) !== null && _d !== void 0 ? _d : []).map((layer) => { var _a; return (_a = layer.Arn) !== null && _a !== void 0 ? _a : ''; });
    const originalLayerARNs = ((_e = config.Layers) !== null && _e !== void 0 ? _e : []).map((layer) => { var _a; return (_a = layer.Arn) !== null && _a !== void 0 ? _a : ''; });
    let needsLayerUpdate = false;
    layerARNs = addLayerARN(fullLambdaLibraryLayerARN, lambdaLibraryLayerArn, layerARNs);
    layerARNs = addLayerARN(fullExtensionLayerARN, lambdaExtensionLayerArn, layerARNs);
    if (originalLayerARNs.sort().join(',') !== layerARNs.sort().join(',')) {
        needsLayerUpdate = true;
    }
    if (needsLayerUpdate) {
        needsUpdate = true;
        updateRequest.Layers = layerARNs;
    }
    layerARNs.forEach((layerARN) => {
        if (layerARN.includes(constants_1.DD_LAMBDA_EXTENSION_LAYER_NAME) &&
            newEnvVars[constants_1.API_KEY_ENV_VAR] === undefined &&
            newEnvVars[constants_1.KMS_API_KEY_ENV_VAR] === undefined) {
            throw new Error(`When 'extensionLayer' is set, ${constants_1.CI_API_KEY_ENV_VAR} or ${constants_1.CI_KMS_API_KEY_ENV_VAR} must also be set`);
        }
    });
    return needsUpdate ? updateRequest : undefined;
};
exports.calculateUpdateRequest = calculateUpdateRequest;
const addLayerARN = (fullLayerARN, partialLayerARN, layerARNs) => {
    if (fullLayerARN) {
        if (!layerARNs.includes(fullLayerARN)) {
            // Remove any other versions of the layer
            layerARNs = [...layerARNs.filter((l) => !l.startsWith(partialLayerARN)), fullLayerARN];
        }
    }
    return layerARNs;
};
const isSupportedRuntime = (runtime) => {
    const lookup = constants_1.RUNTIME_LAYER_LOOKUP;
    return runtime !== undefined && lookup[runtime] !== undefined;
};
