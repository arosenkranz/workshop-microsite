"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.sentenceMatchesRegEx = exports.InstrumentCommand = void 0;
const aws_sdk_1 = require("aws-sdk");
const clipanion_1 = require("clipanion");
const utils_1 = require("../../helpers/utils");
const constants_1 = require("./constants");
const function_1 = require("./function");
class InstrumentCommand extends clipanion_1.Command {
    constructor() {
        super(...arguments);
        this.config = {
            functions: [],
            region: process.env.AWS_DEFAULT_REGION,
            tracing: 'true',
        };
        this.dryRun = false;
        this.functions = [];
    }
    execute() {
        return __awaiter(this, void 0, void 0, function* () {
            const lambdaConfig = { lambda: this.config };
            this.config = (yield utils_1.parseConfigFile(lambdaConfig, this.configPath)).lambda;
            const settings = this.getSettings();
            if (settings === undefined) {
                return 1;
            }
            const hasSpecifiedFuntions = this.functions.length !== 0 || this.config.functions.length !== 0;
            const hasSpecifiedRegExPattern = this.regExPattern !== undefined;
            if (!hasSpecifiedFuntions && !hasSpecifiedRegExPattern) {
                this.context.stdout.write('No functions specified for instrumentation.\n');
                return 1;
            }
            if (settings.extensionVersion && settings.forwarderARN) {
                this.context.stdout.write('"extensionVersion" and "forwarder" should not be used at the same time.\n');
                return 1;
            }
            const configGroups = [];
            if (hasSpecifiedRegExPattern) {
                if (hasSpecifiedFuntions) {
                    const usedCommand = this.functions.length !== 0 ? '"--functions"' : 'Functions in config file';
                    this.context.stdout.write(`${usedCommand} and "--functions-regex" should not be used at the same time.\n`);
                    return 1;
                }
                if (this.regExPattern.match(':')) {
                    this.context.stdout.write(`"--functions-regex" isn't meant to be used with ARNs.\n`);
                    return 1;
                }
                const region = this.region || this.config.region;
                if (!region) {
                    this.context.stdout.write('No default region specified. Use -r,--region,');
                    return 1;
                }
                try {
                    const cloudWatchLogs = new aws_sdk_1.CloudWatchLogs({ region });
                    const lambda = new aws_sdk_1.Lambda({ region });
                    this.context.stdout.write('Fetching lambda functions, this might take a while.\n');
                    const configs = yield function_1.getLambdaConfigsFromRegEx(lambda, cloudWatchLogs, region, this.regExPattern, settings);
                    configGroups.push({ configs, lambda, cloudWatchLogs, region: region });
                }
                catch (err) {
                    this.context.stdout.write(`Couldn't fetch lambda functions. ${err}\n`);
                    return 1;
                }
            }
            else {
                const functionGroups = this.collectFunctionsByRegion();
                if (functionGroups === undefined) {
                    return 1;
                }
                for (const [region, functionList] of Object.entries(functionGroups)) {
                    const lambda = new aws_sdk_1.Lambda({ region });
                    const cloudWatchLogs = new aws_sdk_1.CloudWatchLogs({ region });
                    try {
                        const configs = yield function_1.getLambdaConfigs(lambda, cloudWatchLogs, region, functionList, settings);
                        configGroups.push({ configs, lambda, cloudWatchLogs, region });
                    }
                    catch (err) {
                        this.context.stdout.write(`Couldn't fetch lambda functions. ${err}\n`);
                        return 1;
                    }
                }
            }
            const configList = configGroups.map((group) => group.configs).reduce((a, b) => a.concat(b));
            this.printPlannedActions(configList);
            if (this.dryRun || configList.length === 0) {
                return 0;
            }
            const promises = Object.values(configGroups).map((group) => function_1.updateLambdaConfigs(group.lambda, group.cloudWatchLogs, group.configs));
            try {
                yield Promise.all(promises);
            }
            catch (err) {
                this.context.stdout.write(`Failure during update. ${err}\n`);
                return 1;
            }
            return 0;
        });
    }
    collectFunctionsByRegion() {
        var _a;
        const functions = this.functions.length !== 0 ? this.functions : this.config.functions;
        const defaultRegion = this.region || this.config.region;
        const groups = {};
        const regionless = [];
        for (const func of functions) {
            const region = (_a = this.getRegion(func)) !== null && _a !== void 0 ? _a : defaultRegion;
            if (region === undefined) {
                regionless.push(func);
                continue;
            }
            if (groups[region] === undefined) {
                groups[region] = [];
            }
            const group = groups[region];
            group.push(func);
        }
        if (regionless.length > 0) {
            this.context.stdout.write(`'No default region specified for ${JSON.stringify(regionless)}. Use -r,--region, or use a full functionARN\n`);
            return;
        }
        return groups;
    }
    convertStringBooleanToBoolean(fallback, value, configValue) {
        return value ? value.toLowerCase() === 'true' : configValue ? configValue.toLowerCase() === 'true' : fallback;
    }
    getRegion(functionARN) {
        const [, , , region] = functionARN.split(':');
        return region === undefined || region === '*' ? undefined : region;
    }
    getSettings() {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v;
        const layerVersionStr = (_a = this.layerVersion) !== null && _a !== void 0 ? _a : this.config.layerVersion;
        const extensionVersionStr = (_b = this.extensionVersion) !== null && _b !== void 0 ? _b : this.config.extensionVersion;
        const layerAWSAccount = (_c = this.layerAWSAccount) !== null && _c !== void 0 ? _c : this.config.layerAWSAccount;
        const forwarderARN = (_d = this.forwarder) !== null && _d !== void 0 ? _d : this.config.forwarder;
        let layerVersion;
        if (layerVersionStr !== undefined) {
            layerVersion = parseInt(layerVersionStr, 10);
        }
        if (Number.isNaN(layerVersion)) {
            this.context.stdout.write(`Invalid layer version ${layerVersion}.\n`);
            return;
        }
        let extensionVersion;
        if (extensionVersionStr !== undefined) {
            extensionVersion = parseInt(extensionVersionStr, 10);
        }
        if (Number.isNaN(extensionVersion)) {
            this.context.stdout.write(`Invalid extension version ${extensionVersion}.\n`);
            return;
        }
        const stringBooleansMap = {
            flushMetricsToLogs: (_f = (_e = this.flushMetricsToLogs) === null || _e === void 0 ? void 0 : _e.toLowerCase()) !== null && _f !== void 0 ? _f : (_g = this.config.flushMetricsToLogs) === null || _g === void 0 ? void 0 : _g.toLowerCase(),
            mergeXrayTraces: (_j = (_h = this.mergeXrayTraces) === null || _h === void 0 ? void 0 : _h.toLowerCase()) !== null && _j !== void 0 ? _j : (_k = this.config.mergeXrayTraces) === null || _k === void 0 ? void 0 : _k.toLowerCase(),
            tracing: (_m = (_l = this.tracing) === null || _l === void 0 ? void 0 : _l.toLowerCase()) !== null && _m !== void 0 ? _m : (_o = this.config.tracing) === null || _o === void 0 ? void 0 : _o.toLowerCase(),
        };
        for (const [stringBoolean, value] of Object.entries(stringBooleansMap)) {
            if (!['true', 'false', undefined].includes(value)) {
                this.context.stdout.write(`Invalid boolean specified for ${stringBoolean}.\n`);
                return;
            }
        }
        const flushMetricsToLogs = this.convertStringBooleanToBoolean(true, this.flushMetricsToLogs, this.config.flushMetricsToLogs);
        const mergeXrayTraces = this.convertStringBooleanToBoolean(false, this.mergeXrayTraces, this.config.mergeXrayTraces);
        const tracingEnabled = this.convertStringBooleanToBoolean(true, this.tracing, this.config.tracing);
        const logLevel = (_p = this.logLevel) !== null && _p !== void 0 ? _p : this.config.logLevel;
        const service = (_q = this.service) !== null && _q !== void 0 ? _q : this.config.service;
        const environment = (_r = this.environment) !== null && _r !== void 0 ? _r : this.config.environment;
        const version = (_s = this.version) !== null && _s !== void 0 ? _s : this.config.version;
        const tagsMap = {
            environment,
            service,
            version,
        };
        const tagsMissing = [];
        for (const [tag, value] of Object.entries(tagsMap)) {
            if (!value) {
                tagsMissing.push(tag);
            }
        }
        if (tagsMissing.length > 0) {
            const tags = tagsMissing.join(', ').replace(/, ([^,]*)$/, ' and $1');
            const plural = tagsMissing.length > 1;
            this.context.stdout.write(`Warning: The ${tags} tag${plural ? 's have' : ' has'} not been configured. Learn more about Datadog unified service tagging: https://docs.datadoghq.com/getting_started/tagging/unified_service_tagging/#serverless-environment.\n`);
        }
        const extraTags = (_u = (_t = this.extraTags) === null || _t === void 0 ? void 0 : _t.toLowerCase()) !== null && _u !== void 0 ? _u : (_v = this.config.extraTags) === null || _v === void 0 ? void 0 : _v.toLowerCase();
        if (extraTags && !exports.sentenceMatchesRegEx(extraTags, constants_1.EXTRA_TAGS_REG_EXP)) {
            this.context.stdout.write('Extra tags do not comply with the <key>:<value> array.\n');
            return;
        }
        return {
            environment,
            extensionVersion,
            extraTags,
            flushMetricsToLogs,
            forwarderARN,
            layerAWSAccount,
            layerVersion,
            logLevel,
            mergeXrayTraces,
            service,
            tracingEnabled,
            version,
        };
    }
    printPlannedActions(configs) {
        var _a, _b, _c;
        const prefix = this.dryRun ? '[Dry Run] ' : '';
        let anyUpdates = false;
        for (const config of configs) {
            if (config.updateRequest !== undefined ||
                ((_a = config.logGroupConfiguration) === null || _a === void 0 ? void 0 : _a.createLogGroupRequest) !== undefined ||
                ((_b = config.logGroupConfiguration) === null || _b === void 0 ? void 0 : _b.deleteSubscriptionFilterRequest) !== undefined ||
                ((_c = config.logGroupConfiguration) === null || _c === void 0 ? void 0 : _c.subscriptionFilterRequest) !== undefined ||
                (config === null || config === void 0 ? void 0 : config.tagConfiguration) !== undefined) {
                anyUpdates = true;
                break;
            }
        }
        if (!anyUpdates) {
            this.context.stdout.write(`${prefix}No updates will be applied\n`);
            return;
        }
        this.context.stdout.write(`${prefix}Will apply the following updates:\n`);
        for (const config of configs) {
            if (config.updateRequest) {
                this.context.stdout.write(`UpdateFunctionConfiguration -> ${config.functionARN}\n${JSON.stringify(config.updateRequest, undefined, 2)}\n`);
            }
            const { logGroupConfiguration, tagConfiguration } = config;
            if (tagConfiguration === null || tagConfiguration === void 0 ? void 0 : tagConfiguration.tagResourceRequest) {
                this.context.stdout.write(`TagResource -> ${tagConfiguration.tagResourceRequest.Resource}\n${JSON.stringify(tagConfiguration.tagResourceRequest.Tags, undefined, 2)}\n`);
            }
            if (logGroupConfiguration === null || logGroupConfiguration === void 0 ? void 0 : logGroupConfiguration.createLogGroupRequest) {
                this.context.stdout.write(`CreateLogGroup -> ${logGroupConfiguration.logGroupName}\n${JSON.stringify(logGroupConfiguration.createLogGroupRequest, undefined, 2)}\n`);
            }
            if (logGroupConfiguration === null || logGroupConfiguration === void 0 ? void 0 : logGroupConfiguration.deleteSubscriptionFilterRequest) {
                this.context.stdout.write(`DeleteSubscriptionFilter -> ${logGroupConfiguration.logGroupName}\n${JSON.stringify(logGroupConfiguration.deleteSubscriptionFilterRequest, undefined, 2)}\n`);
            }
            if (logGroupConfiguration === null || logGroupConfiguration === void 0 ? void 0 : logGroupConfiguration.subscriptionFilterRequest) {
                this.context.stdout.write(`PutSubscriptionFilter -> ${logGroupConfiguration.logGroupName}\n${JSON.stringify(logGroupConfiguration.subscriptionFilterRequest, undefined, 2)}\n`);
            }
        }
    }
}
exports.InstrumentCommand = InstrumentCommand;
const sentenceMatchesRegEx = (sentence, regex) => sentence.match(regex);
exports.sentenceMatchesRegEx = sentenceMatchesRegEx;
InstrumentCommand.addPath('lambda', 'instrument');
InstrumentCommand.addOption('functions', clipanion_1.Command.Array('-f,--function'));
InstrumentCommand.addOption('regExPattern', clipanion_1.Command.String('--functions-regex'));
InstrumentCommand.addOption('region', clipanion_1.Command.String('-r,--region'));
InstrumentCommand.addOption('extensionVersion', clipanion_1.Command.String('-e,--extensionVersion'));
InstrumentCommand.addOption('layerVersion', clipanion_1.Command.String('-v,--layerVersion'));
InstrumentCommand.addOption('layerAWSAccount', clipanion_1.Command.String('-a,--layerAccount', { hidden: true }));
InstrumentCommand.addOption('tracing', clipanion_1.Command.String('--tracing'));
InstrumentCommand.addOption('mergeXrayTraces', clipanion_1.Command.String('--mergeXrayTraces'));
InstrumentCommand.addOption('flushMetricsToLogs', clipanion_1.Command.String('--flushMetricsToLogs'));
InstrumentCommand.addOption('dryRun', clipanion_1.Command.Boolean('-d,--dry'));
InstrumentCommand.addOption('configPath', clipanion_1.Command.String('--config'));
InstrumentCommand.addOption('forwarder', clipanion_1.Command.String('--forwarder'));
InstrumentCommand.addOption('logLevel', clipanion_1.Command.String('--logLevel'));
InstrumentCommand.addOption('service', clipanion_1.Command.String('--service'));
InstrumentCommand.addOption('environment', clipanion_1.Command.String('--env'));
InstrumentCommand.addOption('version', clipanion_1.Command.String('--version'));
InstrumentCommand.addOption('extraTags', clipanion_1.Command.String('--extra-tags'));
