"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.UploadCommand = void 0;
const async_retry_1 = __importDefault(require("async-retry"));
const clipanion_1 = require("clipanion");
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const metrics_1 = require("../../helpers/metrics");
const utils_1 = require("../../helpers/utils");
const api_1 = require("./api");
const renderer_1 = require("./renderer");
const errorCodesNoRetry = [400, 403, 413];
class UploadCommand extends clipanion_1.Command {
    constructor() {
        super(...arguments);
        this.config = {
            apiHost: utils_1.getApiHostForSite(process.env.DATADOG_SITE || 'datadoghq.com'),
            apiKey: process.env.DATADOG_API_KEY,
            appKey: process.env.DATADOG_APP_KEY,
        };
        this.dryRun = false;
    }
    execute() {
        return __awaiter(this, void 0, void 0, function* () {
            // Validate input
            if (!this.source) {
                this.context.stderr.write(renderer_1.renderMissingParameter('--source', UploadCommand.SUPPORTED_SOURCES));
                return UploadCommand.INVALID_INPUT_EXIT_CODE;
            }
            if (UploadCommand.SUPPORTED_SOURCES.indexOf(this.source) === -1) {
                this.context.stderr.write(renderer_1.renderUnsupportedParameterValue('--source', this.source, UploadCommand.SUPPORTED_SOURCES));
                return UploadCommand.INVALID_INPUT_EXIT_CODE;
            }
            if (!this.service) {
                this.context.stderr.write(renderer_1.renderMissingParameter('--service'));
                return UploadCommand.INVALID_INPUT_EXIT_CODE;
            }
            if (!this.config.appKey) {
                this.context.stderr.write(renderer_1.renderMissingEnvironmentVariable('DATADOG_APP_KEY'));
                return UploadCommand.INVALID_INPUT_EXIT_CODE;
            }
            if (!this.config.apiKey) {
                this.context.stderr.write(renderer_1.renderMissingEnvironmentVariable('DATADOG_API_KEY'));
                return UploadCommand.INVALID_INPUT_EXIT_CODE;
            }
            // Display warning for missing --release-version
            if (!this.releaseVersion) {
                this.context.stdout.write(renderer_1.renderMissingReleaseVersionParameter());
            }
            // Check if file exists (we are not validating the content of the file)
            this.dependenciesFilePath = path_1.default.resolve(this.dependenciesFilePath);
            if (!fs_1.default.existsSync(this.dependenciesFilePath)) {
                this.context.stderr.write(renderer_1.renderCannotFindFile(this.dependenciesFilePath));
                return UploadCommand.MISSING_FILE_EXIT_CODE;
            }
            const defaultTags = [`service:${this.service}`];
            if (this.releaseVersion) {
                defaultTags.push(`version:${this.releaseVersion}`);
            }
            const metricsLogger = metrics_1.getMetricsLogger({
                datadogSite: process.env.DATADOG_SITE,
                defaultTags,
                prefix: 'datadog.ci.dependencies.',
            });
            // Upload dependencies
            this.context.stdout.write(renderer_1.renderCommandInfo(this.dependenciesFilePath, this.source, this.service, this.releaseVersion, this.dryRun));
            try {
                const initialTime = Date.now();
                const payload = {
                    dependenciesFilePath: this.dependenciesFilePath,
                    service: this.service,
                    source: this.source,
                    version: this.releaseVersion,
                };
                yield this.uploadDependencies(payload, metricsLogger.logger);
                const totalTimeSeconds = (Date.now() - initialTime) / 1000;
                this.context.stdout.write(renderer_1.renderSuccessfulCommand(totalTimeSeconds));
                metricsLogger.logger.gauge('duration', totalTimeSeconds);
            }
            catch (error) {
                this.context.stderr.write(`${error.message}\n`);
                return UploadCommand.UPLOAD_ERROR_EXIT_CODE;
            }
            finally {
                try {
                    yield metricsLogger.flush();
                }
                catch (err) {
                    this.context.stdout.write(`WARN: ${err}\n`);
                }
            }
        });
    }
    uploadDependencies(payload, metricsLogger) {
        return __awaiter(this, void 0, void 0, function* () {
            const api = api_1.apiConstructor(`https://${this.config.apiHost}`, this.config.apiKey, this.config.appKey);
            try {
                yield async_retry_1.default((bail) => __awaiter(this, void 0, void 0, function* () {
                    try {
                        if (this.dryRun) {
                            this.context.stdout.write(renderer_1.renderDryRunUpload());
                            return;
                        }
                        this.context.stdout.write(renderer_1.renderUpload());
                        yield api.uploadDependencies(payload);
                        metricsLogger.increment('success', 1);
                    }
                    catch (error) {
                        if (error.response && !errorCodesNoRetry.includes(error.response.status)) {
                            // If it's an axios error and a status code that is not excluded from retries,
                            // throw the error so that upload is retried
                            throw error;
                        }
                        // If it's another error or an axios error we don't want to retry, bail
                        bail(error);
                        return;
                    }
                }), {
                    onRetry: (error, attempt) => {
                        metricsLogger.increment('retries', 1);
                        this.context.stdout.write(renderer_1.renderRetriedUpload(error.message, attempt));
                    },
                    retries: 5,
                });
            }
            catch (error) {
                if (error.response && error.response.status === 403) {
                    this.context.stdout.write(renderer_1.renderFailedUploadBecauseOf403(error.message));
                }
                else {
                    this.context.stdout.write(renderer_1.renderFailedUpload(error.message));
                }
                metricsLogger.increment('failed', 1);
                throw error;
            }
        });
    }
}
exports.UploadCommand = UploadCommand;
UploadCommand.SUPPORTED_SOURCES = ['snyk'];
UploadCommand.usage = clipanion_1.Command.Usage({
    description: 'Upload dependencies graph to Datadog.',
    details: 'Uploads dependencies graph to Datadog to detect runtime vulnerabilities by Continuous Profiler. See README for details.',
    examples: [
        [
            'Upload dependency graph generated by `snyk test --print-deps --sub-project=my-project --json > ./snyk_deps.json` command',
            'datadog-ci dependencies upload ./snyk_deps.json --source snyk --service my-service --release-version 1.234',
        ],
    ],
});
UploadCommand.INVALID_INPUT_EXIT_CODE = 1;
UploadCommand.MISSING_FILE_EXIT_CODE = 2;
UploadCommand.UPLOAD_ERROR_EXIT_CODE = 3;
UploadCommand.addPath('dependencies', 'upload');
UploadCommand.addOption('dependenciesFilePath', clipanion_1.Command.String({ required: true }));
UploadCommand.addOption('source', clipanion_1.Command.String('--source'));
UploadCommand.addOption('releaseVersion', clipanion_1.Command.String('--release-version'));
UploadCommand.addOption('service', clipanion_1.Command.String('--service'));
UploadCommand.addOption('dryRun', clipanion_1.Command.Boolean('--dry-run'));
