"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getSyntheticsProxy = exports.mockPollResultResponse = exports.mockTestTriggerResponse = exports.mockSearchResponse = exports.getMultiStepsResult = exports.getApiResult = exports.getBrowserResult = exports.getApiPollResult = exports.getBrowserPollResult = exports.getMultiStep = exports.getStep = exports.getApiTest = exports.ciConfig = exports.mockReporter = void 0;
const http = __importStar(require("http"));
const url_1 = require("url");
const ws_1 = require("ws");
const mockUser = {
    email: '',
    handle: '',
    id: 42,
    name: '',
};
exports.mockReporter = {
    error: jest.fn(),
    initErrors: jest.fn(),
    log: jest.fn(),
    reportStart: jest.fn(),
    runEnd: jest.fn(),
    testEnd: jest.fn(),
    testTrigger: jest.fn(),
    testWait: jest.fn(),
};
exports.ciConfig = {
    apiKey: '',
    appKey: '',
    configPath: 'datadog-ci.json',
    datadogSite: 'datadoghq.com',
    failOnCriticalErrors: false,
    failOnTimeout: true,
    files: ['{,!(node_modules)/**/}*.synthetics.json'],
    global: {},
    locations: [],
    pollingTimeout: 2 * 60 * 1000,
    proxy: { protocol: 'http' },
    publicIds: [],
    subdomain: 'app',
    tunnel: false,
};
const getApiTest = (publicId) => ({
    config: {
        assertions: [],
        request: {
            headers: {},
            method: 'GET',
            timeout: 60000,
            url: 'http://fake.url',
        },
        variables: [],
    },
    created_at: '',
    created_by: mockUser,
    locations: [],
    message: '',
    modified_at: '',
    modified_by: mockUser,
    monitor_id: 0,
    name: 'Test name',
    options: {
        device_ids: [],
        min_failure_duration: 0,
        min_location_failed: 0,
        tick_every: 3600,
    },
    overall_state: 0,
    overall_state_modified: '',
    public_id: publicId,
    status: '',
    stepCount: 0,
    subtype: 'http',
    tags: [],
    type: 'api',
});
exports.getApiTest = getApiTest;
const getStep = () => ({
    allowFailure: false,
    browserErrors: [],
    description: 'description',
    duration: 1000,
    skipped: false,
    stepId: -1,
    type: 'type',
    url: 'about:blank',
    value: 'value',
    vitalsMetrics: [
        {
            cls: 1,
            lcp: 1,
            url: 'http://fake.url',
        },
    ],
    warnings: [],
});
exports.getStep = getStep;
const getMultiStep = () => ({
    allowFailure: false,
    assertionResults: [],
    name: 'name',
    passed: true,
    skipped: false,
    subtype: 'subtype',
    timings: {
        total: 123,
    },
});
exports.getMultiStep = getMultiStep;
const getPollResult = () => ({
    dc_id: 1,
    resultID: '123',
    timestamp: 1,
});
const getBrowserPollResult = () => (Object.assign(Object.assign({}, getPollResult()), { result: exports.getBrowserResult() }));
exports.getBrowserPollResult = getBrowserPollResult;
const getApiPollResult = () => (Object.assign(Object.assign({}, getPollResult()), { result: exports.getApiResult() }));
exports.getApiPollResult = getApiPollResult;
const getResult = () => ({
    eventType: 'finished',
    passed: true,
});
const getBrowserResult = (opts = {}) => (Object.assign(Object.assign(Object.assign({}, getResult()), { device: {
        height: 1,
        id: 'laptop_large',
        width: 1,
    }, duration: 0, startUrl: '', stepDetails: [], tunnel: false }), opts));
exports.getBrowserResult = getBrowserResult;
const getApiResult = () => (Object.assign(Object.assign({}, getResult()), { assertionResults: [
        {
            actual: 'actual',
            valid: true,
        },
    ], timings: {
        total: 123,
    } }));
exports.getApiResult = getApiResult;
const getMultiStepsResult = () => (Object.assign(Object.assign({}, getResult()), { duration: 123, steps: [] }));
exports.getMultiStepsResult = getMultiStepsResult;
const mockResult = {
    location: 1,
    public_id: '123-456-789',
    result: {
        dc_id: 1,
        result: {
            device: 'chrome_laptop.large',
            passed: true,
            public_id: '123-456-789',
        },
        result_id: '1',
    },
    result_id: '1',
};
exports.mockSearchResponse = { tests: [{ public_id: '123-456-789' }] };
exports.mockTestTriggerResponse = {
    locations: ['location-1'],
    results: [mockResult],
    triggered_check_ids: ['123-456-789'],
};
exports.mockPollResultResponse = { results: [{ dc_id: 1, result: mockResult, resultID: '1' }] };
const mockTunnelConnectionFirstMessage = { host: 'host', id: 'tunnel-id' };
const getSyntheticsProxy = () => {
    const calls = {
        get: jest.fn(),
        poll: jest.fn(),
        presignedUrl: jest.fn(),
        search: jest.fn(),
        trigger: jest.fn(),
        tunnel: jest.fn(),
    };
    const wss = new ws_1.Server({ noServer: true });
    let port;
    const server = http.createServer({}, (request, response) => {
        const mockResponse = (call, responseData) => {
            let body = '';
            request.on('data', (data) => (body += data.toString()));
            request.on('end', () => {
                try {
                    call(JSON.parse(body));
                }
                catch (_) {
                    call(body);
                }
            });
            return response.end(JSON.stringify(responseData));
        };
        if (!request.url) {
            return response.end();
        }
        if (/\/synthetics\/tests\/search/.test(request.url)) {
            return mockResponse(calls.search, exports.mockSearchResponse);
        }
        if (/\/synthetics\/tests\/trigger\/ci/.test(request.url)) {
            return mockResponse(calls.trigger, exports.mockTestTriggerResponse);
        }
        if (/\/synthetics\/ci\/tunnel/.test(request.url)) {
            return mockResponse(calls.presignedUrl, { url: `ws://127.0.0.1:${port}` });
        }
        if (/\/synthetics\/tests\/poll_results/.test(request.url)) {
            return mockResponse(calls.poll, exports.mockPollResultResponse);
        }
        if (/\/synthetics\/tests\//.test(request.url)) {
            return mockResponse(calls.get, exports.getApiTest('123-456-789'));
        }
        console.log(request.url);
        response.end();
    });
    server.on('upgrade', (request, socket, head) => {
        wss.handleUpgrade(request, socket, head, (ws) => {
            calls.tunnel();
            ws.send(JSON.stringify(mockTunnelConnectionFirstMessage));
        });
    });
    server.listen();
    const address = server.address();
    port = typeof address === 'string' ? Number(new url_1.URL(address).port) : address.port;
    const config = { host: '127.0.0.1', port, protocol: 'http' };
    const close = () => Promise.all([new Promise((res) => server.close(res)), new Promise((res) => wss.close(res))]);
    return { calls, close, config, server };
};
exports.getSyntheticsProxy = getSyntheticsProxy;
