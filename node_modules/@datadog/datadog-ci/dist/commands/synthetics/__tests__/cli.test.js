"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const ciUtils = __importStar(require("../../../helpers/utils"));
const cli_1 = require("../cli");
const interfaces_1 = require("../interfaces");
const runTests = __importStar(require("../run-test"));
const utils = __importStar(require("../utils"));
const fixtures_1 = require("./fixtures");
describe('run-test', () => {
    beforeEach(() => {
        jest.restoreAllMocks();
        jest.spyOn(ciUtils, 'getConfig').mockImplementation(() => __awaiter(void 0, void 0, void 0, function* () { return ({}); }));
        process.env = {};
    });
    describe('getAppBaseURL', () => {
        beforeEach(() => {
            jest.restoreAllMocks();
        });
        test('should default to datadog us', () => __awaiter(void 0, void 0, void 0, function* () {
            process.env = {};
            const command = new cli_1.RunTestCommand();
            expect(command['getAppBaseURL']()).toBe('https://app.datadoghq.com/');
        }));
        test('subdomain should be overridable', () => __awaiter(void 0, void 0, void 0, function* () {
            process.env = { DATADOG_SUBDOMAIN: 'custom' };
            const command = new cli_1.RunTestCommand();
            yield command['resolveConfig']();
            expect(command['getAppBaseURL']()).toBe('https://custom.datadoghq.com/');
        }));
        test('should override subdomain and site', () => __awaiter(void 0, void 0, void 0, function* () {
            process.env = {
                DATADOG_SITE: 'datadoghq.eu',
                DATADOG_SUBDOMAIN: 'custom',
            };
            const command = new cli_1.RunTestCommand();
            yield command['resolveConfig']();
            expect(command['getAppBaseURL']()).toBe('https://custom.datadoghq.eu/');
        }));
    });
    describe('sortTestsByOutcome', () => {
        beforeEach(() => {
            jest.restoreAllMocks();
        });
        const test1 = { options: {}, public_id: 'test1' };
        const test2 = { options: { ci: { executionRule: interfaces_1.ExecutionRule.BLOCKING } }, public_id: 'test2' };
        const test3 = { options: { ci: { executionRule: interfaces_1.ExecutionRule.NON_BLOCKING } }, public_id: 'test3' };
        const test4 = { options: { ci: { executionRule: interfaces_1.ExecutionRule.BLOCKING } }, public_id: 'test4' };
        const test5 = { options: { ci: { executionRule: interfaces_1.ExecutionRule.NON_BLOCKING } }, public_id: 'test5' };
        const tests = [test1, test2, test3, test4, test5];
        const results = {
            test1: [{ result: { passed: true } }],
            test2: [{ result: { passed: true } }],
            test3: [{ result: { passed: true } }],
            test4: [{ result: { passed: false } }],
            test5: [{ result: { passed: false } }],
        };
        test('should sort tests with success, non_blocking failures then failures', () => __awaiter(void 0, void 0, void 0, function* () {
            const command = new cli_1.RunTestCommand();
            tests.sort(command['sortTestsByOutcome'](results));
            expect(tests).toStrictEqual([test3, test1, test2, test5, test4]);
        }));
    });
    describe('resolveConfig', () => {
        beforeEach(() => {
            jest.restoreAllMocks();
            process.env = {};
            jest.spyOn(ciUtils, 'getConfig').mockImplementation(() => __awaiter(void 0, void 0, void 0, function* () { return ({}); }));
        });
        test('override from ENV', () => __awaiter(void 0, void 0, void 0, function* () {
            const overrideEnv = {
                DATADOG_API_KEY: 'fake_api_key',
                DATADOG_APP_KEY: 'fake_app_key',
                DATADOG_SITE: 'datadoghq.eu',
                DATADOG_SUBDOMAIN: 'custom',
            };
            process.env = overrideEnv;
            const command = new cli_1.RunTestCommand();
            yield command['resolveConfig']();
            expect(command['config']).toEqual(Object.assign(Object.assign({}, cli_1.DEFAULT_COMMAND_CONFIG), { apiKey: overrideEnv.DATADOG_API_KEY, appKey: overrideEnv.DATADOG_APP_KEY, datadogSite: overrideEnv.DATADOG_SITE, subdomain: overrideEnv.DATADOG_SUBDOMAIN }));
        }));
        test('override from config file', () => __awaiter(void 0, void 0, void 0, function* () {
            const overrideConfigFile = {
                apiKey: 'fake_api_key',
                appKey: 'fake_app_key',
                configPath: 'fake-datadog-ci.json',
                datadogSite: 'datadoghq.eu',
                failOnCriticalErrors: true,
                failOnTimeout: false,
                files: ['my-new-file'],
                global: { locations: [] },
                locations: [],
                pollingTimeout: 1,
                proxy: { protocol: 'https' },
                publicIds: ['ran-dom-id'],
                subdomain: 'ppa',
                tunnel: true,
            };
            jest.spyOn(ciUtils, 'getConfig').mockImplementation(() => __awaiter(void 0, void 0, void 0, function* () { return overrideConfigFile; }));
            const command = new cli_1.RunTestCommand();
            yield command['resolveConfig']();
            expect(command['config']).toEqual(overrideConfigFile);
        }));
        test('override from CLI', () => __awaiter(void 0, void 0, void 0, function* () {
            const overrideCLI = {
                apiKey: 'fake_api_key',
                appKey: 'fake_app_key',
                configPath: 'fake-datadog-ci.json',
                datadogSite: 'datadoghq.eu',
                failOnCriticalErrors: true,
                failOnTimeout: false,
                files: ['new-file'],
                publicIds: ['ran-dom-id'],
                subdomain: 'new-sub-domain',
                testSearchQuery: 'a-search-query',
                tunnel: true,
            };
            const command = new cli_1.RunTestCommand();
            command['apiKey'] = overrideCLI.apiKey;
            command['appKey'] = overrideCLI.appKey;
            command['configPath'] = overrideCLI.configPath;
            command['datadogSite'] = overrideCLI.datadogSite;
            command['failOnCriticalErrors'] = overrideCLI.failOnCriticalErrors;
            command['failOnTimeout'] = overrideCLI.failOnTimeout;
            command['files'] = overrideCLI.files;
            command['publicIds'] = overrideCLI.publicIds;
            command['subdomain'] = overrideCLI.subdomain;
            command['tunnel'] = overrideCLI.tunnel;
            command['testSearchQuery'] = overrideCLI.testSearchQuery;
            yield command['resolveConfig']();
            expect(command['config']).toEqual(Object.assign(Object.assign({}, cli_1.DEFAULT_COMMAND_CONFIG), { apiKey: 'fake_api_key', appKey: 'fake_app_key', configPath: 'fake-datadog-ci.json', datadogSite: 'datadoghq.eu', failOnCriticalErrors: true, failOnTimeout: false, files: ['new-file'], publicIds: ['ran-dom-id'], subdomain: 'new-sub-domain', testSearchQuery: 'a-search-query', tunnel: true }));
        }));
        test('override from config file < ENV < CLI', () => __awaiter(void 0, void 0, void 0, function* () {
            jest.spyOn(ciUtils, 'getConfig').mockImplementation(() => __awaiter(void 0, void 0, void 0, function* () {
                return ({
                    apiKey: 'api_key_config_file',
                    appKey: 'app_key_config_file',
                    datadogSite: 'datadog.config.file',
                });
            }));
            process.env = {
                DATADOG_API_KEY: 'api_key_env',
                DATADOG_APP_KEY: 'app_key_env',
            };
            const command = new cli_1.RunTestCommand();
            command['apiKey'] = 'api_key_cli';
            yield command['resolveConfig']();
            expect(command['config']).toEqual(Object.assign(Object.assign({}, cli_1.DEFAULT_COMMAND_CONFIG), { apiKey: 'api_key_cli', appKey: 'app_key_env', datadogSite: 'datadog.config.file' }));
        }));
        test('override locations with ENV variable', () => __awaiter(void 0, void 0, void 0, function* () {
            const conf = {
                content: { tests: [{ config: {}, id: 'publicId' }] },
                name: 'Suite 1',
            };
            jest.spyOn(ciUtils, 'parseConfigFile').mockImplementation((config, _) => __awaiter(void 0, void 0, void 0, function* () { return config; }));
            jest.spyOn(utils, 'getSuites').mockImplementation((() => [conf]));
            // Throw to stop the test
            const serverError = new Error('Server Error');
            serverError.response = { data: { errors: ['Bad Gateway'] }, status: 502 };
            serverError.config = { baseURL: 'baseURL', url: 'url' };
            const triggerTests = jest.fn(() => {
                throw serverError;
            });
            const apiHelper = {
                getTest: jest.fn(() => (Object.assign({}, fixtures_1.getApiTest('publicId')))),
                triggerTests,
            };
            const write = jest.fn();
            const command = new cli_1.RunTestCommand();
            command.context = { stdout: { write } };
            command['config'].global = { locations: ['aws:us-east-2'] };
            jest.spyOn(runTests, 'getApiHelper').mockImplementation(() => apiHelper);
            expect(yield command.execute()).toBe(0);
            expect(triggerTests).toHaveBeenCalledWith(expect.objectContaining({
                tests: [{ executionRule: 'blocking', locations: ['aws:us-east-2'], public_id: 'publicId' }],
            }));
            // Env > global
            process.env = {
                DATADOG_SYNTHETICS_LOCATIONS: 'aws:us-east-3',
            };
            expect(yield command.execute()).toBe(0);
            expect(triggerTests).toHaveBeenCalledTimes(2);
            expect(triggerTests).toHaveBeenNthCalledWith(2, expect.objectContaining({
                tests: [{ executionRule: 'blocking', locations: ['aws:us-east-3'], public_id: 'publicId' }],
            }));
            process.env = {
                DATADOG_SYNTHETICS_LOCATIONS: 'aws:us-east-3;aws:us-east-4',
            };
            expect(yield command.execute()).toBe(0);
            expect(triggerTests).toHaveBeenCalledTimes(3);
            expect(triggerTests).toHaveBeenNthCalledWith(3, expect.objectContaining({
                tests: [{ executionRule: 'blocking', locations: ['aws:us-east-3', 'aws:us-east-4'], public_id: 'publicId' }],
            }));
            // Test > env
            const confWithLocation = {
                content: { tests: [{ config: { locations: ['aws:us-east-1'] }, id: 'publicId' }] },
            };
            jest.spyOn(utils, 'getSuites').mockImplementation((() => [confWithLocation]));
            expect(yield command.execute()).toBe(0);
            expect(triggerTests).toHaveBeenCalledWith(expect.objectContaining({
                tests: [{ executionRule: 'blocking', locations: ['aws:us-east-1'], public_id: 'publicId' }],
            }));
        }));
    });
});
