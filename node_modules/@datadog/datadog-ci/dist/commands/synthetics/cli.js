"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RunTestCommand = exports.DEFAULT_COMMAND_CONFIG = void 0;
const chalk_1 = __importDefault(require("chalk"));
const clipanion_1 = require("clipanion");
const deep_extend_1 = __importDefault(require("deep-extend"));
const utils_1 = require("../../helpers/utils");
const errors_1 = require("./errors");
const interfaces_1 = require("./interfaces");
const default_1 = require("./reporters/default");
const junit_1 = require("./reporters/junit");
const run_test_1 = require("./run-test");
const utils_2 = require("./utils");
exports.DEFAULT_COMMAND_CONFIG = {
    apiKey: '',
    appKey: '',
    configPath: 'datadog-ci.json',
    datadogSite: 'datadoghq.com',
    failOnCriticalErrors: false,
    failOnTimeout: true,
    files: ['{,!(node_modules)/**/}*.synthetics.json'],
    global: {},
    locations: [],
    pollingTimeout: 2 * 60 * 1000,
    proxy: { protocol: 'http' },
    publicIds: [],
    subdomain: 'app',
    tunnel: false,
};
class RunTestCommand extends clipanion_1.Command {
    constructor() {
        super(...arguments);
        this.config = JSON.parse(JSON.stringify(exports.DEFAULT_COMMAND_CONFIG)); // Deep copy to avoid mutation during unit tests
    }
    execute() {
        return __awaiter(this, void 0, void 0, function* () {
            const reporters = [new default_1.DefaultReporter(this)];
            this.reporter = utils_2.getReporter(reporters);
            if (this.jUnitReport) {
                reporters.push(new junit_1.JUnitReporter(this));
            }
            yield this.resolveConfig();
            const startTime = Date.now();
            if (this.config.tunnel) {
                this.reporter.log('You are using tunnel option, the chosen location(s) will be overridden by a location in your account region.\n');
            }
            let results;
            let summary;
            let tests;
            let triggers;
            try {
                ;
                ({ results, summary, tests, triggers } = yield run_test_1.executeTests(this.reporter, this.config));
            }
            catch (error) {
                if (error instanceof errors_1.CiError) {
                    this.reportCiError(error, this.reporter);
                    if (error instanceof errors_1.CriticalError && this.config.failOnCriticalErrors) {
                        return 1;
                    }
                }
                return 0;
            }
            return this.renderResults(results, summary, tests, triggers, startTime);
        });
    }
    getAppBaseURL() {
        return `https://${this.config.subdomain}.${this.config.datadogSite}/`;
    }
    renderResults(results, summary, tests, triggers, startTime) {
        var _a, _b, _c, _d;
        // Sort tests to show success first then non blocking failures and finally blocking failures.
        tests.sort(this.sortTestsByOutcome(results));
        // Rendering the results.
        (_a = this.reporter) === null || _a === void 0 ? void 0 : _a.reportStart({ startTime });
        const locationNames = triggers.locations.reduce((mapping, location) => {
            mapping[location.id] = location.display_name;
            return mapping;
        }, {});
        let hasSucceeded = true; // Determine if all the tests have succeeded
        for (const test of tests) {
            const testResults = results[test.public_id];
            if (!this.config.failOnTimeout) {
                if (!summary.timedOut) {
                    summary.timedOut = 0;
                }
                const hasTimeout = testResults.some((pollResult) => pollResult.result.error === interfaces_1.ERRORS.TIMEOUT);
                if (hasTimeout) {
                    summary.timedOut++;
                }
            }
            if (!this.config.failOnCriticalErrors) {
                if (!summary.criticalErrors) {
                    summary.criticalErrors = 0;
                }
                const hasCriticalErrors = testResults.some((pollResult) => utils_2.isCriticalError(pollResult.result));
                if (hasCriticalErrors) {
                    summary.criticalErrors++;
                }
            }
            const passed = utils_2.hasTestSucceeded(testResults, this.config.failOnCriticalErrors, this.config.failOnTimeout);
            if (passed) {
                summary.passed++;
            }
            else {
                summary.failed++;
                if (((_b = test.options.ci) === null || _b === void 0 ? void 0 : _b.executionRule) !== interfaces_1.ExecutionRule.NON_BLOCKING) {
                    hasSucceeded = false;
                }
            }
            (_c = this.reporter) === null || _c === void 0 ? void 0 : _c.testEnd(test, testResults, this.getAppBaseURL(), locationNames, this.config.failOnCriticalErrors, this.config.failOnTimeout);
        }
        (_d = this.reporter) === null || _d === void 0 ? void 0 : _d.runEnd(summary);
        return hasSucceeded ? 0 : 1;
    }
    reportCiError(error, reporter) {
        switch (error.code) {
            case 'NO_RESULTS_TO_POLL':
                reporter.log('No results to poll.\n');
                break;
            case 'NO_TESTS_TO_RUN':
                reporter.log('No test to run.\n');
                break;
            case 'MISSING_APP_KEY':
                reporter.error(`Missing ${chalk_1.default.red.bold('DATADOG_APP_KEY')} in your environment.\n`);
                break;
            case 'MISSING_API_KEY':
                reporter.error(`Missing ${chalk_1.default.red.bold('DATADOG_API_KEY')} in your environment.\n`);
                break;
            case 'POLL_RESULTS_FAILED':
                reporter.error(`\n${chalk_1.default.bgRed.bold(' ERROR: unable to poll test results ')}\n${error.message}\n\n`);
                break;
            case 'TUNNEL_START_FAILED':
                reporter.error(`\n${chalk_1.default.bgRed.bold(' ERROR: unable to start tunnel')}\n${error.message}\n\n`);
                break;
            case 'TRIGGER_TESTS_FAILED':
                reporter.error(`\n${chalk_1.default.bgRed.bold(' ERROR: unable to trigger tests')}\n${error.message}\n\n`);
                break;
            case 'UNAVAILABLE_TEST_CONFIG':
                reporter.error(`\n${chalk_1.default.bgRed.bold(' ERROR: unable to obtain test configurations with search query ')}\n${error.message}\n\n`);
                break;
            case 'UNAVAILABLE_TUNNEL_CONFIG':
                reporter.error(`\n${chalk_1.default.bgRed.bold(' ERROR: unable to get tunnel configuration')}\n${error.message}\n\n`);
        }
    }
    resolveConfig() {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            // Default < file < ENV < CLI
            // Override with file config variables
            try {
                this.config = yield utils_1.parseConfigFile(this.config, (_a = this.configPath) !== null && _a !== void 0 ? _a : this.config.configPath);
            }
            catch (error) {
                if (this.configPath) {
                    throw error;
                }
            }
            // Override with ENV variables
            this.config = deep_extend_1.default(this.config, utils_2.removeUndefinedValues({
                apiKey: process.env.DATADOG_API_KEY,
                appKey: process.env.DATADOG_APP_KEY,
                datadogSite: process.env.DATADOG_SITE,
                locations: (_b = process.env.DATADOG_SYNTHETICS_LOCATIONS) === null || _b === void 0 ? void 0 : _b.split(';'),
                subdomain: process.env.DATADOG_SUBDOMAIN,
            }));
            // Override with CLI parameters
            this.config = deep_extend_1.default(this.config, utils_2.removeUndefinedValues({
                apiKey: this.apiKey,
                appKey: this.appKey,
                configPath: this.configPath,
                datadogSite: this.datadogSite,
                failOnCriticalErrors: this.failOnCriticalErrors,
                failOnTimeout: this.failOnTimeout,
                files: this.files,
                publicIds: this.publicIds,
                subdomain: this.subdomain,
                testSearchQuery: this.testSearchQuery,
                tunnel: this.tunnel,
            }));
            if (typeof this.config.files === 'string') {
                this.reporter.log('[DEPRECATED] "files" should be an array of string instead of a string.\n');
                this.config.files = [this.config.files];
            }
        });
    }
    sortTestsByOutcome(results) {
        return (t1, t2) => {
            var _a, _b;
            const success1 = utils_2.hasTestSucceeded(results[t1.public_id], this.config.failOnCriticalErrors, this.config.failOnTimeout);
            const success2 = utils_2.hasTestSucceeded(results[t2.public_id], this.config.failOnCriticalErrors, this.config.failOnTimeout);
            const isNonBlockingTest1 = ((_a = t1.options.ci) === null || _a === void 0 ? void 0 : _a.executionRule) === interfaces_1.ExecutionRule.NON_BLOCKING;
            const isNonBlockingTest2 = ((_b = t2.options.ci) === null || _b === void 0 ? void 0 : _b.executionRule) === interfaces_1.ExecutionRule.NON_BLOCKING;
            if (success1 === success2) {
                if (isNonBlockingTest1 === isNonBlockingTest2) {
                    return 0;
                }
                return isNonBlockingTest1 ? -1 : 1;
            }
            return success1 ? -1 : 1;
        };
    }
}
exports.RunTestCommand = RunTestCommand;
RunTestCommand.addPath('synthetics', 'run-tests');
RunTestCommand.addOption('apiKey', clipanion_1.Command.String('--apiKey'));
RunTestCommand.addOption('appKey', clipanion_1.Command.String('--appKey'));
RunTestCommand.addOption('failOnCriticalErrors', clipanion_1.Command.Boolean('--failOnCriticalErrors'));
RunTestCommand.addOption('configPath', clipanion_1.Command.String('--config'));
RunTestCommand.addOption('datadogSite', clipanion_1.Command.String('--datadogSite'));
RunTestCommand.addOption('files', clipanion_1.Command.Array('-f,--files'));
RunTestCommand.addOption('failOnTimeout', clipanion_1.Command.Boolean('--failOnTimeout'));
RunTestCommand.addOption('publicIds', clipanion_1.Command.Array('-p,--public-id'));
RunTestCommand.addOption('testSearchQuery', clipanion_1.Command.String('-s,--search'));
RunTestCommand.addOption('subdomain', clipanion_1.Command.Boolean('--subdomain'));
RunTestCommand.addOption('tunnel', clipanion_1.Command.Boolean('-t,--tunnel'));
RunTestCommand.addOption('runName', clipanion_1.Command.String('-n,--runName'));
