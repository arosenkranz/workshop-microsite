"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DefaultReporter = void 0;
const chalk_1 = __importDefault(require("chalk"));
const interfaces_1 = require("../interfaces");
const utils_1 = require("../utils");
// Step rendering
const renderStepDuration = (duration) => {
    const getColor = () => {
        if (duration > 10000) {
            return chalk_1.default.bold.red;
        }
        if (duration > 5000) {
            return chalk_1.default.bold.yellow;
        }
        return chalk_1.default.bold;
    };
    const color = getColor();
    return `${color(duration.toString())}ms`;
};
const ICONS = {
    FAILED: chalk_1.default.bold.red('✖'),
    SKIPPED: chalk_1.default.bold.yellow('⇢'),
    SUCCESS: chalk_1.default.bold.green('✓'),
};
const renderStepIcon = (step) => {
    if (step.error) {
        return ICONS.FAILED;
    }
    if (step.skipped) {
        return ICONS.SKIPPED;
    }
    return ICONS.SUCCESS;
};
const renderStep = (step) => {
    const duration = renderStepDuration(step.duration);
    const icon = renderStepIcon(step);
    const value = step.value ? `\n      ${chalk_1.default.dim(step.value)}` : '';
    const error = step.error ? `\n      ${chalk_1.default.red.dim(step.error)}` : '';
    return `    ${icon} | ${duration} - ${step.description}${value}${error}`;
};
const readableOperation = {
    [interfaces_1.Operator.contains]: 'should contain',
    [interfaces_1.Operator.doesNotContain]: 'should not contain',
    [interfaces_1.Operator.is]: 'should be',
    [interfaces_1.Operator.isNot]: 'should not be',
    [interfaces_1.Operator.lessThan]: 'should be less than',
    [interfaces_1.Operator.matches]: 'should match',
    [interfaces_1.Operator.doesNotMatch]: 'should not match',
    [interfaces_1.Operator.validates]: 'will expire in less than',
    [interfaces_1.Operator.isInLessThan]: 'will expire in less than',
    [interfaces_1.Operator.isInMoreThan]: 'will expire in more than',
};
const renderApiError = (errorCode, errorMessage, color) => {
    if (errorCode === 'INCORRECT_ASSERTION') {
        try {
            const assertionsErrors = JSON.parse(errorMessage);
            const output = [' - Assertion(s) failed:'];
            output.push(...assertionsErrors.map((error) => {
                const expected = chalk_1.default.underline(`${error.target}`);
                const actual = chalk_1.default.underline(`${error.actual}`);
                return `▶ ${error.type} ${readableOperation[error.operator]} ${expected}. Actual: ${actual}`;
            }));
            return color(output.join('\n      '));
        }
        catch (e) {
            // JSON parsing failed, do nothing to return the raw error
        }
    }
    return chalk_1.default.red(`      [${chalk_1.default.bold(errorCode)}] - ${chalk_1.default.dim(errorMessage)}`);
};
// Test execution rendering
const renderResultOutcome = (result, test, icon, color, failOnCriticalErrors, failOnTimeout) => {
    // Only display critical errors if failure is not filled.
    if (result.error && !(result.failure || result.errorMessage)) {
        return `    ${chalk_1.default.bold(`${ICONS.FAILED} | ${result.error}`)}`;
    }
    if (result.unhealthy) {
        const errorMessage = result.failure ? result.failure.message : result.errorMessage;
        const errorName = errorMessage && errorMessage !== 'Unknown error' ? errorMessage : 'General Error';
        return [
            `    ${chalk_1.default.yellow(` ${ICONS.SKIPPED} | ${errorName}`)}`,
            `    ${chalk_1.default.yellow('We had an error during the execution of this test. The result will be ignored')}`,
        ].join('\n');
    }
    if (test.type === 'api') {
        const requestDescription = renderApiRequestDescription(test.subtype, test.config);
        if (result.failure || (result.errorCode && result.errorMessage)) {
            const errorCode = result.failure ? result.failure.code : result.errorCode;
            const errorMessage = result.failure ? result.failure.message : result.errorMessage;
            return [`    ${icon} ${color(requestDescription)}`, renderApiError(errorCode, errorMessage, color)].join('\n');
        }
        return `    ${icon} ${color(requestDescription)}`;
    }
    if (test.type === 'browser') {
        if (!utils_1.hasResultPassed(result, failOnCriticalErrors, failOnTimeout) && 'stepDetails' in result) {
            // We render the step only if the test hasn't passed to avoid cluttering the output.
            return result.stepDetails.map(renderStep).join('\n');
        }
        return '';
    }
};
const renderApiRequestDescription = (subType, config) => {
    const { request, steps } = config;
    if (subType === 'dns') {
        const text = `Query for ${request.host}`;
        if (request.dnsServer) {
            return `${text} on server ${request.dnsServer}`;
        }
        return text;
    }
    if (subType === 'ssl' || subType === 'tcp') {
        return `Host: ${request.host}:${request.port}`;
    }
    if (subType === 'multi' && steps) {
        const stepsDescription = Object.entries(steps
            .map((step) => step.subtype)
            .reduce((counts, type) => {
            counts[type] = (counts[type] || 0) + 1;
            return counts;
        }, {}))
            .map(([type, count]) => `${count} ${type.toUpperCase()} test`)
            .join(', ');
        return `Multistep test containing ${stepsDescription}`;
    }
    if (subType === 'http') {
        return `${chalk_1.default.bold(request.method)} - ${request.url}`;
    }
    return `${chalk_1.default.bold(subType)} test`;
};
const getResultUrl = (baseUrl, test, resultId) => {
    const ciQueryParam = 'from_ci=true';
    const testDetailUrl = `${baseUrl}synthetics/details/${test.public_id}`;
    if (test.type === 'browser') {
        return `${testDetailUrl}/result/${resultId}?${ciQueryParam}`;
    }
    return `${testDetailUrl}?resultId=${resultId}&${ciQueryParam}`;
};
const renderExecutionResult = (test, execution, baseUrl, locationNames, failOnCriticalErrors, failOnTimeout) => {
    var _a;
    const { check: overridedTest, dc_id, resultID, result } = execution;
    const isSuccess = utils_1.hasResultPassed(result, failOnCriticalErrors, failOnTimeout);
    const color = getTestResultColor(isSuccess, ((_a = test.options.ci) === null || _a === void 0 ? void 0 : _a.executionRule) === interfaces_1.ExecutionRule.NON_BLOCKING);
    const icon = isSuccess ? ICONS.SUCCESS : ICONS.FAILED;
    const locationName = !!result.tunnel ? 'Tunneled' : locationNames[dc_id] || dc_id.toString();
    const device = test.type === 'browser' && 'device' in result ? ` - device: ${chalk_1.default.bold(result.device.id)}` : '';
    const resultIdentification = color(`  ${icon} location: ${chalk_1.default.bold(locationName)}${device}`);
    const outputLines = [resultIdentification];
    // Unhealthy test results don't have a duration or result URL
    if (!result.unhealthy) {
        const duration = utils_1.getResultDuration(result);
        const durationText = duration ? `  total duration: ${duration} ms -` : '';
        const resultUrl = getResultUrl(baseUrl, test, resultID);
        const resultUrlStatus = result.error === interfaces_1.ERRORS.TIMEOUT ? '(not yet received)' : '';
        const resultInfo = `    ⎋${durationText} result url: ${chalk_1.default.dim.cyan(resultUrl)} ${resultUrlStatus}`;
        outputLines.push(resultInfo);
    }
    const resultOutcome = renderResultOutcome(result, overridedTest || test, icon, color, failOnCriticalErrors, failOnTimeout);
    if (resultOutcome) {
        outputLines.push(resultOutcome);
    }
    return outputLines.join('\n');
};
// Results of all tests rendering
const renderResultIcon = (success, isNonBlocking) => {
    if (success) {
        return ICONS.SUCCESS;
    }
    if (isNonBlocking) {
        return ICONS.SKIPPED;
    }
    return ICONS.FAILED;
};
const getTestResultColor = (success, isNonBlocking) => {
    if (success) {
        return chalk_1.default.bold.green;
    }
    if (isNonBlocking) {
        return chalk_1.default.bold.yellow;
    }
    return chalk_1.default.bold.red;
};
class DefaultReporter {
    constructor({ context }) {
        this.write = context.stdout.write.bind(context.stdout);
    }
    error(error) {
        this.write(error);
    }
    initError(errors) {
        this.write(errors.join('\n'));
    }
    log(log) {
        this.write(log);
    }
    reportStart(timings) {
        const delay = (Date.now() - timings.startTime).toString();
        this.write(['\n', chalk_1.default.bold.cyan('=== REPORT ==='), `Took ${chalk_1.default.bold(delay)}ms`, '\n'].join('\n'));
    }
    runEnd(summary) {
        const summaries = [
            chalk_1.default.green(`${chalk_1.default.bold(summary.passed)} passed`),
            chalk_1.default.red(`${chalk_1.default.bold(summary.failed)} failed`),
        ];
        if (summary.skipped) {
            summaries.push(`${chalk_1.default.bold(summary.skipped)} skipped`);
        }
        if (summary.notFound) {
            summaries.push(chalk_1.default.yellow(`${chalk_1.default.bold(summary.notFound)} not found`));
        }
        const extraInfo = [];
        if (summary.timedOut) {
            extraInfo.push(chalk_1.default.yellow(`${chalk_1.default.bold(summary.timedOut)} timed out`));
        }
        if (summary.criticalErrors) {
            extraInfo.push(chalk_1.default.red(`${chalk_1.default.bold(summary.criticalErrors)} critical errors`));
        }
        this.write(`${chalk_1.default.bold('Tests execution summary:')} ${summaries.join(', ')}${extraInfo.length ? ' (' + extraInfo.join(', ') + ')' : ''}\n`);
    }
    testEnd(test, results, baseUrl, locationNames, failOnCriticalErrors, failOnTimeout) {
        var _a;
        const success = utils_1.hasTestSucceeded(results, failOnCriticalErrors, failOnTimeout);
        const isNonBlocking = ((_a = test.options.ci) === null || _a === void 0 ? void 0 : _a.executionRule) === interfaces_1.ExecutionRule.NON_BLOCKING;
        const icon = renderResultIcon(success, isNonBlocking);
        const idDisplay = `[${chalk_1.default.bold.dim(test.public_id)}]`;
        const nameColor = getTestResultColor(success, isNonBlocking);
        const nonBlockingText = !success && isNonBlocking ? '[NON-BLOCKING]' : '';
        const testResultsText = results
            .map((r) => renderExecutionResult(test, r, baseUrl, locationNames, failOnCriticalErrors, failOnTimeout))
            .join('\n\n')
            .concat('\n\n');
        this.write([`${icon} ${idDisplay}${nonBlockingText} | ${nameColor(test.name)}`, testResultsText].join('\n'));
    }
    testTrigger(test, testId, executionRule, config) {
        const idDisplay = `[${chalk_1.default.bold.dim(testId)}]`;
        const getMessage = () => {
            if (executionRule === interfaces_1.ExecutionRule.SKIPPED) {
                // Test is either skipped from datadog-ci config or from test config
                const isSkippedByCIConfig = config.executionRule === interfaces_1.ExecutionRule.SKIPPED;
                if (isSkippedByCIConfig) {
                    return `>> Skipped test "${chalk_1.default.yellow.dim(test.name)}"`;
                }
                else {
                    return `>> Skipped test "${chalk_1.default.yellow.dim(test.name)}" because of execution rule configuration in Datadog`;
                }
            }
            if (executionRule === interfaces_1.ExecutionRule.NON_BLOCKING) {
                return `Trigger test "${chalk_1.default.green.bold(test.name)}" (non-blocking)`;
            }
            return `Trigger test "${chalk_1.default.green.bold(test.name)}"`;
        };
        this.write(`${idDisplay} ${getMessage()}\n`);
    }
    testWait(test) {
        const idDisplay = `[${chalk_1.default.bold.dim(test.public_id)}]`;
        this.write(`${idDisplay} Waiting results for "${chalk_1.default.green.bold(test.name)}"\n`);
    }
}
exports.DefaultReporter = DefaultReporter;
