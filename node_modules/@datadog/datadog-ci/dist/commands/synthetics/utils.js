"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.removeUndefinedValues = exports.retry = exports.runTests = exports.getTestsToTrigger = exports.getReporter = exports.getResultDuration = exports.createTriggerResultMap = exports.waitForResults = exports.wait = exports.getSuites = exports.hasTestSucceeded = exports.hasResultPassed = exports.isCriticalError = exports.getStrictestExecutionRule = exports.getExecutionRule = exports.handleConfig = void 0;
const fs = __importStar(require("fs"));
const path = __importStar(require("path"));
const url_1 = require("url");
const util_1 = require("util");
const chalk_1 = __importDefault(require("chalk"));
const glob_1 = __importDefault(require("glob"));
const ci_1 = require("../../helpers/ci");
const utils_1 = require("../../helpers/utils");
const api_1 = require("./api");
const interfaces_1 = require("./interfaces");
const POLLING_INTERVAL = 5000; // In ms
const PUBLIC_ID_REGEX = /^[\d\w]{3}-[\d\w]{3}-[\d\w]{3}$/;
const SUBDOMAIN_REGEX = /(.*?)\.(?=[^\/]*\..{2,5})/;
const TEMPLATE_REGEX = /{{\s*([^{}]*?)\s*}}/g;
const template = (st, context) => st.replace(TEMPLATE_REGEX, (match, p1) => (p1 in context ? context[p1] : match));
const handleConfig = (test, publicId, reporter, config) => {
    const executionRule = exports.getExecutionRule(test, config);
    let handledConfig = {
        executionRule,
        public_id: publicId,
    };
    if (!config || !Object.keys(config).length) {
        return handledConfig;
    }
    handledConfig = Object.assign(Object.assign({}, handledConfig), utils_1.pick(config, [
        'allowInsecureCertificates',
        'basicAuth',
        'body',
        'bodyType',
        'cookies',
        'defaultStepTimeout',
        'deviceIds',
        'followRedirects',
        'headers',
        'locations',
        'pollingTimeout',
        'retry',
        'tunnel',
        'variables',
    ]));
    if ((test.type === 'browser' || test.subtype === 'http') && config.startUrl) {
        const context = parseUrlVariables(test.config.request.url, reporter);
        handledConfig.startUrl = template(config.startUrl, context);
    }
    return handledConfig;
};
exports.handleConfig = handleConfig;
const parseUrlVariables = (url, reporter) => {
    const context = Object.assign(Object.assign({}, process.env), { URL: url });
    let objUrl;
    try {
        objUrl = new url_1.URL(url);
    }
    catch (_a) {
        reporter.error(`The start url ${url} contains variables, CI overrides will be ignored\n`);
        return context;
    }
    warnOnReservedEnvVarNames(context, reporter);
    const subdomainMatch = objUrl.hostname.match(SUBDOMAIN_REGEX);
    const domain = subdomainMatch ? objUrl.hostname.replace(`${subdomainMatch[1]}.`, '') : objUrl.hostname;
    context.DOMAIN = domain;
    context.HASH = objUrl.hash;
    context.HOST = objUrl.host;
    context.HOSTNAME = objUrl.hostname;
    context.ORIGIN = objUrl.origin;
    context.PARAMS = objUrl.search;
    context.PATHNAME = objUrl.pathname;
    context.PORT = objUrl.port;
    context.PROTOCOL = objUrl.protocol;
    context.SUBDOMAIN = subdomainMatch ? subdomainMatch[1] : undefined;
    return context;
};
const warnOnReservedEnvVarNames = (context, reporter) => {
    const reservedVarNames = new Set([
        'DOMAIN',
        'HASH',
        'HOST',
        'HOSTNAME',
        'ORIGIN',
        'PARAMS',
        'PATHNAME',
        'PORT',
        'PROTOCOL',
        'SUBDOMAIN',
    ]);
    const usedEnvVarNames = Object.keys(context).filter((name) => reservedVarNames.has(name));
    if (usedEnvVarNames.length > 0) {
        const names = usedEnvVarNames.join(', ');
        const plural = usedEnvVarNames.length > 1;
        reporter.log(`Detected ${names} environment variable${plural ? 's' : ''}. ${names} ${plural ? 'are' : 'is a'} Datadog ` +
            `reserved variable${plural ? 's' : ''} used to parse your original test URL, read more about it on ` +
            'our documentation https://docs.datadoghq.com/synthetics/ci/?tab=apitest#start-url. ' +
            'If you want to override your startUrl parameter using environment variables, ' +
            `use ${plural ? '' : 'a '}different namespace${plural ? 's' : ''}.\n\n`);
    }
};
const getExecutionRule = (test, configOverride) => {
    var _a, _b, _c, _d;
    if (configOverride && configOverride.executionRule) {
        return exports.getStrictestExecutionRule(configOverride.executionRule, (_b = (_a = test.options) === null || _a === void 0 ? void 0 : _a.ci) === null || _b === void 0 ? void 0 : _b.executionRule);
    }
    return ((_d = (_c = test.options) === null || _c === void 0 ? void 0 : _c.ci) === null || _d === void 0 ? void 0 : _d.executionRule) || interfaces_1.ExecutionRule.BLOCKING;
};
exports.getExecutionRule = getExecutionRule;
const getStrictestExecutionRule = (configRule, testRule) => {
    if (configRule === interfaces_1.ExecutionRule.SKIPPED || testRule === interfaces_1.ExecutionRule.SKIPPED) {
        return interfaces_1.ExecutionRule.SKIPPED;
    }
    if (configRule === interfaces_1.ExecutionRule.NON_BLOCKING || testRule === interfaces_1.ExecutionRule.NON_BLOCKING) {
        return interfaces_1.ExecutionRule.NON_BLOCKING;
    }
    if (configRule === interfaces_1.ExecutionRule.BLOCKING || testRule === interfaces_1.ExecutionRule.BLOCKING) {
        return interfaces_1.ExecutionRule.BLOCKING;
    }
    return interfaces_1.ExecutionRule.BLOCKING;
};
exports.getStrictestExecutionRule = getStrictestExecutionRule;
const isCriticalError = (result) => result.unhealthy || result.error === interfaces_1.ERRORS.ENDPOINT;
exports.isCriticalError = isCriticalError;
const hasResultPassed = (result, failOnCriticalErrors, failOnTimeout) => {
    if (exports.isCriticalError(result) && !failOnCriticalErrors) {
        return true;
    }
    if (result.error === interfaces_1.ERRORS.TIMEOUT && !failOnTimeout) {
        return true;
    }
    if (typeof result.passed !== 'undefined') {
        return result.passed;
    }
    if (typeof result.errorCode !== 'undefined') {
        return false;
    }
    return true;
};
exports.hasResultPassed = hasResultPassed;
const hasTestSucceeded = (results, failOnCriticalErrors, failOnTimeout) => results.every((pollResult) => exports.hasResultPassed(pollResult.result, failOnCriticalErrors, failOnTimeout));
exports.hasTestSucceeded = hasTestSucceeded;
const getSuites = (GLOB, reporter) => __awaiter(void 0, void 0, void 0, function* () {
    reporter.log(`Finding files in ${path.join(process.cwd(), GLOB)}\n`);
    const files = yield util_1.promisify(glob_1.default)(GLOB);
    if (files.length) {
        reporter.log(`\nGot test files:\n${files.map((file) => `  - ${file}\n`).join('')}\n`);
    }
    else {
        reporter.log('\nNo test files found.\n\n');
    }
    return Promise.all(files.map((file) => __awaiter(void 0, void 0, void 0, function* () {
        try {
            const content = yield util_1.promisify(fs.readFile)(file, 'utf8');
            return { name: file, content: JSON.parse(content) };
        }
        catch (e) {
            throw new Error(`Unable to read and parse the test file ${file}`);
        }
    })));
});
exports.getSuites = getSuites;
const wait = (duration) => __awaiter(void 0, void 0, void 0, function* () { return new Promise((resolve) => setTimeout(resolve, duration)); });
exports.wait = wait;
const waitForResults = (api, triggerResponses, defaultTimeout, triggerConfigs, tunnel, failOnCriticalErrors) => __awaiter(void 0, void 0, void 0, function* () {
    const triggerResultMap = exports.createTriggerResultMap(triggerResponses, defaultTimeout, triggerConfigs);
    const triggerResults = [...triggerResultMap.values()];
    const maxPollingTimeout = Math.max(...triggerResults.map((tr) => tr.pollingTimeout));
    const pollingStartDate = new Date().getTime();
    let isTunnelConnected = true;
    if (tunnel) {
        tunnel
            .keepAlive()
            .then(() => (isTunnelConnected = false))
            .catch(() => (isTunnelConnected = false));
    }
    while (triggerResults.filter((tr) => !tr.result).length) {
        const pollingDuration = new Date().getTime() - pollingStartDate;
        // Remove test which exceeded their pollingTimeout
        for (const triggerResult of triggerResults.filter((tr) => !tr.result)) {
            if (pollingDuration >= triggerResult.pollingTimeout) {
                triggerResult.result = createFailingResult(interfaces_1.ERRORS.TIMEOUT, triggerResult.result_id, triggerResult.device, triggerResult.location, !!tunnel);
            }
        }
        if (tunnel && !isTunnelConnected) {
            for (const triggerResult of triggerResults.filter((tr) => !tr.result)) {
                triggerResult.result = createFailingResult(interfaces_1.ERRORS.TUNNEL, triggerResult.result_id, triggerResult.device, triggerResult.location, !!tunnel);
            }
        }
        if (pollingDuration >= maxPollingTimeout) {
            break;
        }
        let polledResults;
        const triggerResultsSucceed = triggerResults.filter((tr) => !tr.result);
        try {
            polledResults = (yield api.pollResults(triggerResultsSucceed.map((tr) => tr.result_id))).results;
        }
        catch (error) {
            if (api_1.is5xxError(error) && !failOnCriticalErrors) {
                polledResults = [];
                for (const triggerResult of triggerResultsSucceed) {
                    triggerResult.result = createFailingResult(interfaces_1.ERRORS.ENDPOINT, triggerResult.result_id, triggerResult.device, triggerResult.location, !!tunnel);
                }
            }
            else {
                throw error;
            }
        }
        for (const polledResult of polledResults) {
            if (polledResult.result.eventType === 'finished') {
                const triggeredResult = triggerResultMap.get(polledResult.resultID);
                if (triggeredResult) {
                    triggeredResult.result = polledResult;
                }
            }
        }
        if (!triggerResults.filter((tr) => !tr.result).length) {
            break;
        }
        yield exports.wait(POLLING_INTERVAL);
    }
    // Bundle results by public id
    return triggerResults.reduce((resultsByPublicId, triggerResult) => {
        const result = triggerResult.result; // The result exists, as either polled or filled with a timeout result
        resultsByPublicId[triggerResult.public_id] = [...(resultsByPublicId[triggerResult.public_id] || []), result];
        return resultsByPublicId;
    }, {});
});
exports.waitForResults = waitForResults;
const createTriggerResultMap = (triggerResponses, defaultTimeout, triggerConfigs) => {
    var _a, _b;
    const timeoutByPublicId = {};
    for (const trigger of triggerConfigs) {
        timeoutByPublicId[trigger.id] = (_a = trigger.config.pollingTimeout) !== null && _a !== void 0 ? _a : defaultTimeout;
    }
    const triggerResultMap = new Map();
    for (const triggerResponse of triggerResponses) {
        triggerResultMap.set(triggerResponse.result_id, Object.assign(Object.assign({}, triggerResponse), { pollingTimeout: (_b = timeoutByPublicId[triggerResponse.public_id]) !== null && _b !== void 0 ? _b : defaultTimeout }));
    }
    return triggerResultMap;
};
exports.createTriggerResultMap = createTriggerResultMap;
const createFailingResult = (errorMessage, resultId, deviceId, dcId, tunnel) => ({
    dc_id: dcId,
    result: {
        device: { height: 0, id: deviceId, width: 0 },
        duration: 0,
        error: errorMessage,
        eventType: 'finished',
        passed: false,
        startUrl: '',
        stepDetails: [],
        tunnel,
    },
    resultID: resultId,
    timestamp: 0,
});
const getResultDuration = (result) => {
    if ('duration' in result) {
        return result.duration;
    }
    if ('timings' in result) {
        return result.timings.total;
    }
    return 0;
};
exports.getResultDuration = getResultDuration;
const getReporter = (reporters) => ({
    error: (error) => {
        for (const reporter of reporters) {
            if (typeof reporter.error === 'function') {
                reporter.error(error);
            }
        }
    },
    initErrors: (errors) => {
        for (const reporter of reporters) {
            if (typeof reporter.initErrors === 'function') {
                reporter.initErrors(errors);
            }
        }
    },
    log: (log) => {
        for (const reporter of reporters) {
            if (typeof reporter.log === 'function') {
                reporter.log(log);
            }
        }
    },
    reportStart: (timings) => {
        for (const reporter of reporters) {
            if (typeof reporter.reportStart === 'function') {
                reporter.reportStart(timings);
            }
        }
    },
    runEnd: (summary) => {
        for (const reporter of reporters) {
            if (typeof reporter.runEnd === 'function') {
                reporter.runEnd(summary);
            }
        }
    },
    testEnd: (test, results, baseUrl, locationNames, failOnCriticalErrors, failOnTimeout) => {
        for (const reporter of reporters) {
            if (typeof reporter.testEnd === 'function') {
                reporter.testEnd(test, results, baseUrl, locationNames, failOnCriticalErrors, failOnTimeout);
            }
        }
    },
    testTrigger: (test, testId, executionRule, config) => {
        for (const reporter of reporters) {
            if (typeof reporter.testTrigger === 'function') {
                reporter.testTrigger(test, testId, executionRule, config);
            }
        }
    },
    testWait: (test) => {
        for (const reporter of reporters) {
            if (typeof reporter.testWait === 'function') {
                reporter.testWait(test);
            }
        }
    },
});
exports.getReporter = getReporter;
const getTestsToTrigger = (api, triggerConfigs, reporter) => __awaiter(void 0, void 0, void 0, function* () {
    const overriddenTestsToTrigger = [];
    const errorMessages = [];
    const summary = { criticalErrors: 0, failed: 0, notFound: 0, passed: 0, skipped: 0, timedOut: 0 };
    const tests = yield Promise.all(triggerConfigs.map(({ config, id, suite }) => __awaiter(void 0, void 0, void 0, function* () {
        let test;
        id = PUBLIC_ID_REGEX.test(id) ? id : id.substr(id.lastIndexOf('/') + 1);
        try {
            test = Object.assign(Object.assign({}, (yield api.getTest(id))), { suite });
        }
        catch (e) {
            if (api_1.is5xxError(e)) {
                throw e;
            }
            summary.notFound++;
            const errorMessage = api_1.formatBackendErrors(e);
            errorMessages.push(`[${chalk_1.default.bold.dim(id)}] ${chalk_1.default.yellow.bold('Test not found')}: ${errorMessage}\n`);
            return;
        }
        const overriddenConfig = exports.handleConfig(test, id, reporter, config);
        overriddenTestsToTrigger.push(overriddenConfig);
        reporter.testTrigger(test, id, overriddenConfig.executionRule, config);
        if (overriddenConfig.executionRule === interfaces_1.ExecutionRule.SKIPPED) {
            summary.skipped++;
        }
        else {
            reporter.testWait(test);
            return test;
        }
    })));
    // Display errors at the end of all tests for better visibility.
    reporter.initErrors(errorMessages);
    if (!overriddenTestsToTrigger.length) {
        throw new Error('No tests to trigger');
    }
    return { tests: tests.filter(definedTypeGuard), overriddenTestsToTrigger, summary };
});
exports.getTestsToTrigger = getTestsToTrigger;
const runTests = (api, testsToTrigger) => __awaiter(void 0, void 0, void 0, function* () {
    const payload = { tests: testsToTrigger };
    const ciMetadata = ci_1.getCIMetadata();
    if (ciMetadata) {
        payload.metadata = ciMetadata;
    }
    try {
        return yield api.triggerTests(payload);
    }
    catch (e) {
        const errorMessage = api_1.formatBackendErrors(e);
        const testIds = testsToTrigger.map((t) => t.public_id).join(',');
        // Rewrite error message
        throw new api_1.EndpointError(`[${testIds}] Failed to trigger tests: ${errorMessage}\n`, e.response.status);
    }
});
exports.runTests = runTests;
const definedTypeGuard = (o) => !!o;
const retry = (func, shouldRetryAfterWait) => __awaiter(void 0, void 0, void 0, function* () {
    const trier = (retries = 0) => __awaiter(void 0, void 0, void 0, function* () {
        try {
            return yield func();
        }
        catch (e) {
            const waiter = shouldRetryAfterWait(retries, e);
            if (waiter) {
                yield exports.wait(waiter);
                return trier(retries + 1);
            }
            throw e;
        }
    });
    return trier();
});
exports.retry = retry;
const removeUndefinedValues = (object) => {
    const newObject = Object.assign({}, object);
    for (const [key, value] of Object.entries(newObject)) {
        if (value === undefined) {
            delete newObject[key];
        }
    }
    return newObject;
};
exports.removeUndefinedValues = removeUndefinedValues;
